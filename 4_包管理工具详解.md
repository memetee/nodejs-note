## 代码共享方案

我们已经学习了在JavaScript中可以通过模块化的方式将代码划分成一个个小的结构：

- 在以后的开发中我们就可以通过模块化的方式来封装自己的代码，并且封装成一个工具；
- 这个工具我们可以让同事通过导入的方式来使用，甚至你可以分享给世界各地的程序员来使用；

如果我们分享给世界上所有的程序员使用，有哪些方式呢？

- 方式一：上传到GitHub上、其他程序员通过GitHub下载我们的代码手动的引用；
  - 缺点是大家必须知道你的代码GitHub的地址，并且从GitHub上手动下载；
  - 需要在自己的项目中手动的引用，并且管理相关的依赖；
  - 不需要使用的时候，需要手动来删除相关的依赖；
  - 当遇到版本升级或者切换时，需要重复上面的操作；

显然，上面的方式是有效的，但是这种传统的方式非常麻烦，并且容易出错；

![image-20220816074933126](.\.\assets\4_包管理工具详解.assets\image-20220816074933126.png)

如果放到github上，发布一个版本就需要上传一次，别人也就需要下载一次



- 方式二：使用一个专业的工具来管理我们的代码
  - 我们通过工具将代码发布到特定的位置；
  - 其他程序员直接通过工具来安装、升级、删除我们的工具代码；

显然，通过第二种方式我们可以更好的管理自己的工具包，其他人也可以更好的使用我们的工具包。









## 包管理工具npm



### 包管理工具简介：

- Node Package Manager，也就是Node包管理器，最早是node开发的工具；
- 但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包；
- 比如vue、vue-router、vuex、express、koa、react、react-dom、axios、babel、webpack等等；



### 下载npm

- npm属于node的一个管理工具，所以我们需要先安装Node；
- node管理工具：https://nodejs.org/en/



### 查看/搜索npm管理的包

- https://www.npmjs.org/
- 这是我们安装相关的npm包的官网；
- 这个网址的作用是帮助你搜索的，但是你发布的包并不是放到这个网站的



### npm管理的包存放

- 我们发布自己的包其实是发布到registry上面的；
- 当我们安装一个包时其实是从registry上面下载的包；





## npm的配置文件



### 如何使用npm来管理这么多包呢？

- 事实上，我们每一个项目都会有一个对应的配置文件，无论是前端项目（Vue、React）还是后端项目 （Node）；
- 这个配置文件会记录着你项目的名称、版本号、项目描述等；
- 也会记录着你项目所依赖的其他库的信息和依赖库的版本号；

![image-20220816080203769](.\.\assets\4_包管理工具详解.assets\image-20220816080203769.png)

这个配置文件就是package.json



### package.json文件介绍

这里有vue和react脚手架的package.json文件的截图

![image-20220726132642924](.\.\assets\4_包管理工具详解.assets\image-20220726132642924.png)

Vue CLI4创建的Vue3项目

![image-20220726132714577](.\.\assets\4_包管理工具详解.assets\image-20220726132714577.png)

create-react-app创建的react17项目

![image-20220726132742229](.\.\assets\4_包管理工具详解.assets\image-20220726132742229.png)

那么这个配置文件如何得到呢？



#### 方式一：手动从零创建项目

npm init –y或者是npm init然后自己来配置包的内容

![image-20220816080538342](.\.\assets\4_包管理工具详解.assets\image-20220816080538342.png)

配置出来的内容

![image-20220816080646416](.\.\assets\4_包管理工具详解.assets\image-20220816080646416.png)

当然也可以用npm init -y(注意中文名字不行)

```js
npm init #创建时填写信息 

npm init -y # 所有信息使用默认的  
```





#### 方式二：通过脚手架创建项目，脚手架会帮助我们生成package.json，并且里面有相关的配置 

这个上面就有截图





## package.json文件常见的属性

必须填写的属性：name、version

- name是项目的名称；
- version是当前项目的版本号；
- description是描述信息，很多时候是作为项目的基本描述；
- author是作者相关信息（发布时用到）；
- license是开源协议（发布时用到）；

private属性：

- private属性记录当前的项目是否是私有的；
- 当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式；



### main属性

- 设置程序的入口。
- 很多人会有疑惑，webpack不是会自动找到程序的入口吗？
  - 当使用webpack的时候webpack要求你有一个入口的，可能你配置的入口是一个main.js，那么我既然在webpack配置入口了，那么这个地方还需要一个入口吗？
    - 在开发前端项目的时候配置这个入口是没有意义的，我们的代码交给webpack来管理了，那么webapck会帮助我们配置入口文件，并且打包
    - 那么写这个东西有什么意义呢，它的意义在于，当有一天你写了一个工具，你把这个工具开源出去了，别人的项目可能会安装你这个包，安装之后，会require这个包，这个时候，会根据package.json来找到这个入口，你写的入口是什么，就会找到这个文件
  - 这个入口和webpack打包的入口并不冲突；
  - 它是在你发布一个模块的时候会用到的；
  - 比如我们使用axios模块 const axios = require('axios');
  - 实际上是找到对应的main属性查找文件的；

![image-20220726133119680](.\.\assets\4_包管理工具详解.assets\image-20220726133119680.png)

![image-20220817071913552](.\.\assets\4_包管理工具详解.assets\image-20220817071913552.png)



cli没有main，因为这个不是给别人用的，但是一般开源的都是有main，比如axios



### script属性

#### script属性的应用

- webpack 在执行的时候可能要执行 webpack serve

- vite在执行的时候可能要执行vite serve

这样它们就不太统一，它们没有统一的规范

那怎么办呢？

![image-20220817072734019](.\.\assets\4_包管理工具详解.assets\image-20220817072734019.png)

通过npm run serve，实际上会去scripts中查找脚本

![image-20220817072844911](.\.\assets\4_包管理工具详解.assets\image-20220817072844911.png)

我们可以指定运行的文件



#### script属性的介绍

- scripts属性用于配置一些脚本命令，以键值对的形式存在；
- 配置后我们可以通过 npm run 命令的key来执行这个命令；
- npm start和npm run start的区别是什么？
  - 它们是等价的；
  - 对于常用的 start、 test、stop、restart可以省略掉run直接通过 npm start等方式运行；



### dependencies属性

#### dependencies的应用

执行npm install axios

![image-20220817073341384](.\.\assets\4_包管理工具详解.assets\image-20220817073341384.png)

1. 所有依赖的包都会在dependencies中，他会做一个记录的

2. 我们一般给同事代码，不会把node_modules给同事的

3. 同事拿到这个package,直接执行npm install 下载dependencies里面的依赖

4. 首先axios的开发不是自己从0开发的，他也是有依赖其他的库的，所以我们下载axios不仅仅需要下载axios，还需要下载axios的依赖，如果确定axios的依赖呢，就是通过axios的dependencies来安装

![image-20220817073944140](.\.\assets\4_包管理工具详解.assets\image-20220817073944140.png)

上面dependencies是会打包到项目中去的，也就是这里面所有的依赖都会打包的



#### dependencies的介绍

- dependencies属性是指定无论开发环境还是生成环境都需要依赖的包；
- 通常是我们项目实际开发用到的一些库模块vue、vuex、vue-router、react、react-dom、axios等等；
- 与之对应的是devDependencies，它是开发阶段使用的包；
- npm install webpack --save是安装到这个里面
- 在开发服务器阶段，这个东西是有意义的，但是在webpack环境下这个东西是没有意义的，因为webpack环境会组成一个依赖图，如果没有被依赖的包是不会被打包的
- 如果在生产环境我不想安装这个里面的包要怎么办呢？
- `npm install --production`来安装依赖不会安装devDependencies这个里面的包

webpack作为一个打包工具，会打包到项目中吗？实际上不会的，因为webpack只是帮我们把代码打包，打包成浏览器可以运行的代码，它本身并不会打包到项目中去，所以你不需要把他安装到dependencies中去，那么要把它们安装到哪里去呢？



### devDependencies属性

-  一些包在生成环境是不需要的，比如webpack、babel等；
-  这个时候我们会通过 npm install webpack --save-dev，将它安装到devDependencies属性中；
-  那么在生产环境如何保证不安装这些包呢？生产环境不需要安装时，我们需要通过npm install --production来安装文件的依赖,这个命令一般在服务器开发的时候才会用

![image-20220817075134799](.\.\assets\4_包管理工具详解.assets\image-20220817075134799.png)



### peerDependencies属性



#### peerDependencies属性的介绍

- peer对等的

- 还有一种项目依赖关系是对等依赖，也就是你依赖的一个包，它必须是以另外一个宿主包为前提的；
- 比如element-plus是依赖于vue3的，ant design是依赖于react、react-dom；

如果用到element-ui或者antd，element是vue的ui包，也就是element是用在vue中的，如果没有vue，那么就不能安装element

看一下如果安装了会怎么样呢

![image-20220817075335277](.\.\assets\4_包管理工具详解.assets\image-20220817075335277.png)

他确实会安装上，但是会给我们一个警告，意思是，element是依赖vue3的，但是我们没有vue3，a peer of vue3的意思是：一个同等的vue3。他为什么会报这样一个警告呢？因为他加了这样一个属性

![image-20220817075530172](.\.\assets\4_包管理工具详解.assets\image-20220817075530172.png)

![image-20220817075634626](.\.\assets\4_包管理工具详解.assets\image-20220817075634626.png)

加了之后，他如果发现，你在安装element的时候没有vue3，他就会发出一个警告，他必须以一个宿主为前提



### engines属性

engines属性（引擎的意思）

- engines属性用于指定Node和NPM的版本号；
- 在安装的过程中，会先检查对应的引擎版本，如果不符合就会报错；
- 事实上也可以指定所在的操作系统 "os" : [ "darwin", "linux" ]，只是很少用到；

![image-20220820084805339](.\.\assets\4_包管理工具详解.assets\image-20220820084805339.png)

在现在是没有engines属性的，

但是在早起的vue-cli创建的vue2项目，其实就有配置engines， 他有创建node的版本，就是要求你的node版本不低于多少，也会配置npm版本，必须满足，npm不低于多少

![image-20220820085311280](.\.\assets\4_包管理工具详解.assets\image-20220820085311280.png)

这样的话，才能运行这个项目

但是现在的话很少配置这个东西，最好不要让我们的node版本太低，如果检测到node版本太低的话，会给我们报错

也可以配置操作系统，只是很少用到





### browserslist属性

- 用于配置打包后的JavaScript浏览器的兼容情况，参考；
- 否则我们需要手动的添加polyfills来让支持某些语法；
- 也就是说它是为webpack等打包工具服务的一个属性（这里不是详细讲解webpack等工具的工作原理，所以不 再给出详情）；

![image-20220820085631758](.\.\assets\4_包管理工具详解.assets\image-20220820085631758.png)

这些东西，并不是package.json本身的配置，这些都是库的配置，比如browserslist这个库，他就是用来将es6转成es5,或者css的转化，这个时候，有一些工具他会读取browserslist的配置，读取这些配置的话，就可以对应的来适配，但是，这些东西，也可以单独的写上一个配置文件

![image-20220820085943903](.\.\assets\4_包管理工具详解.assets\image-20220820085943903.png)

我们可以写成一个单独的文件，也可以写到package.json中

![image-20220820090106128](.\.\assets\4_包管理工具详解.assets\image-20220820090106128.png)

 写到这两个地方都是可以的

比如，vue3中就是写成了一个单独的文件，但是react中就写到了package.json中

![image-20220820090215078](.\.\assets\4_包管理工具详解.assets\image-20220820090215078.png)

因为browserslist中会做一个读取的，也就是说，他会先查找你有没有配置文件，如果有配置文件，就读取你的配置文件，如果没有配置文件，再来看一下你package.json中有没有配置的字段，如果有，那就来你的package.json中读取配置字段，那么是先读取哪个呢？

`不同的工具有不同的读取顺序，因为在实际开发中配置一个就行了`





## 依赖的版本管理

 我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思呢？

### semver版本规范

 npm的包通常需要遵从semver版本规范：

![image-20220817080021477](.\.\assets\4_包管理工具详解.assets\image-20220817080021477.png)

- semver：https://semver.org/lang/zh-CN/
- npm semver：https://docs.npmjs.com/misc/semver



#### X.Y.Z

semver版本规范是X.Y.Z：

- X主版本号（major）：当你做了不兼容的 API 修改（可能不兼容之前的版本，也有可能做了重大修改）；
- Y次版本号（minor）：当你做了向下兼容的功能性新增（新功能增加，但是兼容之前的版本）；
- Z修订号（patch）：当你做了向下兼容的问题修正（没有新功能，修复了之前版本的bug）；



#### ^和~的区别

我们这里解释一下 ^和~的区别：

- ^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；
- ~x.y.z：表示x和y保持不变的，z永远安装最新的版本；

![image-20220817080231393](.\.\assets\4_包管理工具详解.assets\image-20220817080231393.png)

![image-20220817081338703](.\.\assets\4_包管理工具详解.assets\image-20220817081338703.png)

上面这种情况时package.json中vue的版本是^2.6.14,但是实际vue的版本已经更新到2.7.11了,那么在没有package-lock的情况下，用npm install 安装的版本实际上是2.7.11。

那么如果vue的版本变成了3.7.11呢？是不变的，也就是说还是只会安装2.7.11,主版本是不变的

如果package-lock.json文件存在，并且指定了版本号，那么即使有 ^ 并且有最新的版本，那么也不会安装最新的版本，而是会安装package-lock指定版本





## npm install 命令

安装npm包分两种情况：

- 全局安装（global install）： npm install webpack -g; （针对的是整个计算机）
- 项目（局部）安装（local install）： npm install webpack；（针对的是项目）

### 全局安装

- 全局安装是直接将某个包安装到全局：
  - 会将这个东西添加到环境变量中
  - 在电脑的任何一个文件夹都可以使用
  - 如果是局部安装，那么出了项目文件夹就不可以使用了
- 比如yarn的全局安装：

```js
npm install webpack -g
```

但是很多人对全局安装有一些误会：

- 通常使用npm全局安装的包都是一些工具包：yarn、webpack等；
- 并不是类似于 axios、express、koa等库文件；
- 所以全局安装了之后并不能让我们在所有的项目中使用 axios等库；
- 因为node在查找依赖的时候（一层一层的往上找node_modules），并不会找到全局里面的axios



那么到底要全局安装，还是要使用局部安装呢？

在src中要用到的包，比如开发和生产时的依赖，我们全部都要做局部安装。

为什么要局部安装呢？

因为每个项目的依赖版本都不一样，只要安装到全局的东西，那么这个东西都是作为一个工具的属性去使用的，而不是作为项目的包，我们的源代码里面不会包含这些包的（工具包），基本上不会出现一个 npm install axios -g的，所以，安装到全局的一般都是作为工具属性的，我们需要打包到项目中，或者说src中用到的依赖，都不会全局安装的。

![image-20220820092022082](.\.\assets\4_包管理工具详解.assets\image-20220820092022082.png)

但是有时候我们也会对webpack全局安装，为什么要这样做呢？

我们在全局安装了之后，我们就会在任何地方都可以输入

```js
webpack 
```

这样的话，我们就可以对这个文件夹执行webpack命令，如果这个文件夹有webpack操作指令的话，就会执行对应的操作，但是我们会发现，我们就算全局安装了之后，我们还是会在项目中安装一个webpack，那么为什么会这样做呢？

首先要知道，每个项目依赖的webpack依赖的版本是不一样的，我们要根据项目的webpack来安装，因为如果不这样做，是会有问题的，所以全局的安装，只是我们自己测试，但是项目中是不能用全局安装的依赖



### 局部安装

当执行npm install的时候，就会将下载的包放到一个叫node_modules的文件夹中，项目安装会在当前目录下生产一个 node_modules 文件夹，我们之前讲解require查找顺序时有讲解过这个包在什 么情况下被查找；

局部安装分为开发时依赖和生产时依赖：

```js
# 安装开发和生产依赖
npm install axios
npm i axios
# 开发依赖
npm install webpack --save-dev
npm install webpack -D
npm i webpack –D
# 根据package.json中的依赖包
npm install

```

![image-20220820092708131](.\.\assets\4_包管理工具详解.assets\image-20220820092708131.png)

这两个不同的东西，实际上是不同时期的依赖，也就是项目打包结束后，是没有devDependencies中依赖的信息的，他只是作为工具，帮助我们在开发时，将我们开发的代码转换成生成环境需要的代码，但是有些项目没有对它们做严格的区分的，如果我们把开发时依赖放到dependencies中，也就是放到生产时依赖中，会不会报错呢？

是不会的，他其实对开发项目，是没有太大的影响，因为我们在打包项目的时候，webpack会从入口对我们的项目进行解析的，他会打包到所有依赖的包，只有在依赖中的库才会打包，但是我们不要这样做，这样我们才会在package.json中看的时候是一目了然的。

但是有些项目还是会这样做，比如element

![image-20220820093151586](.\.\assets\4_包管理工具详解.assets\image-20220820093151586.png)

当使用npm install element-plus --save(npm install webpack -S)

![image-20220820093257208](.\.\assets\4_包管理工具详解.assets\image-20220820093257208.png)

这个时候就会安装到dependencies中

如果使用npm install webpack --save-dev(npm install webpack -D)

![image-20220820093338605](.\.\assets\4_包管理工具详解.assets\image-20220820093338605.png)

就会安装到devDependencies



### npm install 原理

很多同学之前应该已经会了 npm install ，但是你是否思考过它的内部原理呢？

- 执行 npm install它背后帮助我们完成了什么操作？
- 我们会发现还有一个成为package-lock.json的文件，它的作用是什么？
- 从npm5开始，npm支持缓存策略（来自yarn的压力），缓存有什么作用呢？

这是一幅我画出的根据 npm install 的原理图：

![image-20220726203138409](.\.\assets\4_包管理工具详解.assets\image-20220726203138409.png)



当执行npm install 的时候，怎么安装依赖的呢？

npm install会检测是有package-lock.json文件：

- 没有lock文件
  - 分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况；
  - 从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；
  - 获取到压缩包后会对压缩包进行缓存（从npm5开始有的）；
  - 将压缩包解压到项目的node_modules文件夹中（前面我们讲过，require的查找顺序会在该包下面查找）
- 有lock文件
  - 检测lock中包的版本是否和package.json中一致（会按照semver版本规范检测）；
    - 不一致，那么会重新构建依赖关系，直接会走顶层的流程；
  - 一致的情况下，会去优先查找缓存
    - 没有找到，会从registry仓库下载，直接走顶层流程；
  - 查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中；



比如有两个项目，两个项目分别安装webpack，它们是怎么执行呢？

![image-20220820093806990](.\.\assets\4_包管理工具详解.assets\image-20220820093806990.png)

首先这个包在哪里呢？

包是在registry的



#### registry仓库

![image-20220820094031448](.\.\assets\4_包管理工具详解.assets\image-20220820094031448.png)

webpack的开发团队通过将webpack开发好了，以后，通过npm publish将代码提交到registry中，然后在我的电脑如果有使用到webpack，那么就会去registry中进行下载，而且假设我的电脑有两个项目都用到了webpack，那么他就会下载两次webpack

早期的时候，我不管你的电脑有没有webpack，只要你的项目依赖了webpack，只要你执行了npm install 我就会去registry中进行下载，如果这样做的话，每次我都要去服务器去下载，很占带宽的。所以早起的npm 是非常不好用的，它的安装速度是非常慢的，他也没有缓存，它版本也是很混乱，所以那个时候就出现了一个工具：yarn，npm意识到自己岌岌可危了，所以就一直更新，现在就很好用了

那么现在的npm是什么样的呢？



#### npm install下载做了什么

他会先从registry中将webpack下载下来，下载下来的是一个压缩包，对应的压缩包有一个自己的配置文件，记录着这个压缩包的版本号，名称，做一个记录，这个记录叫做索引

![image-20220820094556478](.\.\assets\4_包管理工具详解.assets\image-20220820094556478.png)

当我们通过npm install 去安装这个项目的时候，并不会直接取registry去下载这个依赖的，而是会先去我的电脑中去找配置文件，看看能不能找到配置文件，如果能找到配置文件，会根据配置文件的索引去找到压缩包的，那如果版本不一致呢？那他会重新下载一个的，如果版本一致，他会拿到这个压缩包，把这个压缩包做一个解压，解压之后会将解压后的文件放到node_modules中，你就不用去registry去重新下载这个依赖了

![image-20220820095108932](.\.\assets\4_包管理工具详解.assets\image-20220820095108932.png)

这样就很大程度节省了带宽，很大程度的提高速度了，并且还有一个很大的好处就是，当前对registry的压力小很多了这个就是npm install 大概的流程。那么我们还有一个package-log这个文件，这个又是做什么呢？npm具体流程是什么样呢？

首先我们没有手动创建过package-log文件，npm install axios在执行这个的时候做了什么事呢？

![image-20220820095823461](.\.\assets\4_包管理工具详解.assets\image-20220820095823461.png)

他会先在当前项目检查一下，有没有package-log.json文件，为什么需要有这么一个文件呢？

前面讲过package.json记录的版本号不是它真实的版本号比如^或者~，这样就会造成一个问题，加入没有log文件，把项目开发完以后，把代码提交到代码仓，另一个同事下载这个代码，肯定不会上传node_modules，同事下载下来后，需要执行npm install 安装依赖，根据什么来安装呢？根据package.json，如果在安装的时候axios已经更新到最新的了，那么就意味着，同事安装的是最新的，但是我们用的版本并不是最新的，因为axios的更新是发生在我们第一次安装之后，那么我们开发完代码，上传到仓库，同事在安装，那肯定和我们安装的版本不一致的，如果更新后的代码是不能用的，就会导致项目在同事的电脑跑不起来了

![image-20220820100730503](.\.\assets\4_包管理工具详解.assets\image-20220820100730503.png)





#### 依赖包的查找原理

因为package.json的版本不是一个明确的版本，就会导致安装的时候，可能会安装到不同的版本的依赖，进而有可能导致某一个项目在不同的电脑是否能运行起来，所以可以多出来一个文件，这个文件就叫package-log.json文件

![image-20220820100936591](.\.\assets\4_包管理工具详解.assets\image-20220820100936591.png)





#### package-lock.json

name：项目的名称；

version：项目的版本；

lockfileVersion：lock文件的版本；

requires：使用requires来跟踪模块的依赖关系， 也就是说，A包依赖B包，那么把这个B也下载下来；

dependencies：项目的依赖

- 当前项目依赖axios，但是axios依赖follow-redireacts；
- axios中的属性如下：
  - version表示实际安装的axios的版本；
  - resolved用来记录下载的地址，registry仓库中的位置；
  - requires记录当前模块的依赖；
  - integrity用来从缓存中获取索引，再通过索引去获取压缩包文件；

![image-20220726203502709](.\.\assets\4_包管理工具详解.assets\image-20220726203502709.png)

![image-20220821003327334](.\.\assets\4_包管理工具详解.assets\image-20220821003327334.png)

这里是有明确的版本的，如果把代码共享给同事，我们把package.json文件和package-lock.json文件给同时共享给同事，所以，同事在下载的时候，会检查到package-lock文件，那么就会根据package-lock.json文件的版本号来下载依赖的

如果第一次的时候没有package-lock文件，那么他会去regisry查找axios库，查找完axios以后，他会去看axios会依赖什么包，因为axios可能会依赖其他的包，所以我们也需要把axios依赖的包给他下载下来

就比如axios就依赖这个包

![image-20220820231137986](.\.\assets\4_包管理工具详解.assets\image-20220820231137986.png)

当他构建好了依赖关系以后，他就回去registry里面给他下载下来，这里下载的就是follo-redirects

但是它下载下来的是压缩包文件，下载下来以后会将压缩包添加到缓存里面去，等缓存完了之后， 会将缓存中的压缩包解压到项目的node_modules文件夹中

这样就有源代码了

![image-20220820231502927](.\.\assets\4_包管理工具详解.assets\image-20220820231502927.png)

源代码有了之后，当前就完成了安装，但是不算完，因为刚才没有lock文件，没有lock文件就不能固定在解压的时候我具体安装了哪一个包，因为有^,所以我不能确定我安装的是更新的版本呢，还是就是0.24.0呢，这就导致我不能对它记录，这个时候就会帮我们生成一个文件，package-loack.json这个文件，这个文件记录我们当前到底使用的是哪个版本的包，上面是没有package-loack.json文件的时候是会这样做的，顺序是这样的

![image-20220821000147854](.\.\assets\4_包管理工具详解.assets\image-20220821000147854.png)

它是按照这种顺序来的

那么，如果已经有package-lock.json文件呢？

首先会看我们安装的版本是否和lock文件中的版本是否是一致的

什么意思呢？就是说假设我们安装npm install axios@0.26.1，但是在lock.json中记录的版本是0.24.0，这个时候它们是不一致的

不一致怎么办呢？

会重新构建依赖，然后根据要安装的最新的依赖，来下载对应的安装包，然后给他解压到node_modules中，然后会生成新的package-lock.json的

![image-20220821000644688](.\.\assets\4_包管理工具详解.assets\image-20220821000644688.png)



那么如果一致呢？

也就是通过对比，现在要安装的版本和我之前安装的版本是一致的，也就是和pack-lock.json文件记录的版本是一致的，已经安装过的版本是没有必要重新安装的，那么就会查找缓存， 怎么去查找缓存呢？

![image-20220821001034173](.\.\assets\4_包管理工具详解.assets\image-20220821001034173.png)

也就是利用上面这个值来查找对应的索引

那么在哪里查找对应的索引呢？

我们要看到对应的缓存时放到哪里的



#### 依赖包的缓存

执行命令

```js
npm get cache
```

他会给你一个对应的文件夹

![image-20220821001232133](.\.\assets\4_包管理工具详解.assets\image-20220821001232133.png)

![image-20220821001332098](.\.\assets\4_包管理工具详解.assets\image-20220821001332098.png)

当我们通过npm install 下载的时候，如果他有缓存的话，他就是被缓存到这里的

![image-20220821001535556](.\.\assets\4_包管理工具详解.assets\image-20220821001535556.png)

tmp是临时文件，不用管，他随时有可能会删除的

index-v5: 对应的是索引，就是在这里找到的只是一个索引，这个索引有记录一些信息，然后通过记录的信息去另外的文件夹找，也就是去content文件夹找，他就是具体的内容了

我们具体的包都是在content中的

那么整个流程是什么样呢？

![image-20220821001726957](.\.\assets\4_包管理工具详解.assets\image-20220821001726957.png)

通过这个值找到索引

来到index-v2中找到对应的索引

![image-20220821001800301](.\.\assets\4_包管理工具详解.assets\image-20220821001800301.png)

找到的索引其实是一些配置信息

![image-20220821001914125](.\.\assets\4_包管理工具详解.assets\image-20220821001914125.png)

这里有时间，大小等配置信息，会记录很多这种东西，这里没有包含压缩包，它仅仅是一个配置，然后通过索引去content找到对应的文件

![image-20220821002138778](.\.\assets\4_包管理工具详解.assets\image-20220821002138778.png)

这里还原的值，应该是还原前面package-lock通过算法生成的一个值，然后又通过算法还原了，然后通过这个值去content去找到对应的文件

找到以后会做一个解压，然后将解压的文件放到了node_modules中，之后我们在node_modules中看到的源文件就是这么来的

那么缓存可能被删掉了，那么就去registry仓库重新下载

然后拿到压缩包，并且将压缩包再次缓存

这个就是npm install的原理的整个流程





## npm其他命令

我们这里再介绍几个比较常用的：

卸载某个依赖包：

```js
npm uninstall package
npm uninstall package --save-dev
npm uninstall package -D
```

强制重新build

```js
npm rebuild
```

清除缓存

```js
npm cache clean
```

npm的命令其实是非常多的：

- https://docs.npmjs.com/cli-documentation/cli
- 更多的命令，可以根据需要查阅官方文档



 



## yarn工具 

早期的npm

![image-20220821101210293](.\.\assets\4_包管理工具详解.assets\image-20220821101210293.png)



另一个node包管理工具yarn：

下载yarn

```js
npm install yarn
```

- yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具；
- yarn 是为了弥补 npm 的一些缺陷而出现的；
- 早期的npm存在很多的缺陷，比如安装依赖速度很慢、版本依赖混乱等等一系列的问题；
- 虽然从npm5版本开始，进行了很多的升级和改进，但是依然很多人喜欢使用yarn；



### yarn与npm的对比

![image-20220726203708987](.\.\assets\4_包管理工具详解.assets\image-20220726203708987.png)

yarn不能和npm混用

![image-20220821101636292](.\.\assets\4_包管理工具详解.assets\image-20220821101636292.png)

![image-20220821101754923](.\.\assets\4_包管理工具详解.assets\image-20220821101754923.png)

它不是一个.json文件，它是一个.lock的文件

和npm一样的

![image-20220821101835209](.\.\assets\4_包管理工具详解.assets\image-20220821101835209.png)

既然它们不一样，就不要即用npm的package.json和yarn.lock进行混用





## cnpm工具

由于一些特殊的原因，某些情况下我们没办法很好的从 https://registry.npmjs.org下载下来一些需要的包。

![image-20220821102415245](.\.\assets\4_包管理工具详解.assets\image-20220821102415245.png)

这个我们就可以做一个拷贝的版本，也就是将国外的registry仓库拷贝到国内的服务器中，所以我们可以将我们下载的地址修改成https://registry.npm.taobao.org，这样我们下载的依赖就会在国内的服务器里面下载了



### 查看npm镜像

```js
npm config get registry # npm config get registry
```

我们可以直接设置npm的镜像：

```js
npm config set registry https://registry.npm.taobao.org
```

但是对于大多数人来说（比如我），并不希望将npm镜像修改了：

- 第一，不太希望随意修改npm原本从官方下来包的渠道；
- 第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去；
- 第三，它不是实时的，它是十分钟进行一次的更新

这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像：

```js
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm config get registry # https://r.npm.taobao.org/
```

这样，实际上设置完了cnpm之后，我就有两个工具了，我的npm指向的还是国外的官方的registry，我的cnpm指向的是国内的淘宝镜像，这样我就可以选择了



## npx工具

npx是和node一起安装的

npx是npm5.2之后自带的一个命令。

- npx的作用非常多，但是比较常见的是使用它来调用项目中的某个模块的指令。

我们以webpack为例：

- 全局安装的是webpack5.1.3
- 项目安装的是webpack3.6.0



### 全局环境执行webpack

如果我进入到项目的路径下，并在终端执行 webpack --version使用的是哪一个命令呢？

- 显示结果会是 webpack 5.1.3，事实上使用的是全局的，为什么呢？
- 原因非常简单，在当前目录下找不到webpack时，就会去全局找，并且执行命令；

![image-20220821105301105](.\.\assets\4_包管理工具详解.assets\image-20220821105301105.png)

当我们在项目的根目录找不到webpack这个命令的时候，他就会去往外找，找到计算机的环境变量，只要在全局安装了webpack，那么webpack在安装的时候就会配置到环境变量中，那么就意味着，不管我们在哪敲，只要它没有这个命令，就会去环境变量中找，找到的就是全局的webpack，既然找到的是全局的，但是我又想用局部的，那么怎么办呢？

就是我们要找到这个命令，那么怎么找到呢？

![image-20220821105835753](.\.\assets\4_包管理工具详解.assets\image-20220821105835753.png)

所以，这里敲的肯定是全局的webpack，也就是在环境变量找的，但是我现在不想用全局的，我想用我这个项目安装的局部的，那么怎么办呢？



### 局部环境执行webpack方法一

明确查找到node_module下面的webpack, 在终端中使用如下命令（在项目根目录下）

```js
./node_modules/.bin/webpack --version
```

![image-20220821110426883](.\.\assets\4_包管理工具详解.assets\image-20220821110426883.png)

![image-20220821110448401](.\.\assets\4_包管理工具详解.assets\image-20220821110448401.png)

这样就可以拿到版本了，但是这样太麻烦了，另外一个办法，在package.json写一个脚本



### 局部环境执行webpack方法二

在 scripts定义脚本，来执行webpack； 

```js
"scripts": {
	"webpack": "webpack --version"
}
```

![image-20220821110554896](.\.\assets\4_包管理工具详解.assets\image-20220821110554896.png)

![image-20220821110632914](.\.\assets\4_包管理工具详解.assets\image-20220821110632914.png)

我们执行这个脚本的时候，这个脚本就会执行webpack --version

这样时候就能找到项目内的webpack了，所以 webpack --version得到的就是项目内的版本

他会优先找本地，如果本地找不到，再找全局，如果要这样的话，必须要先增加一个脚本命令

如果你还嫌这样麻烦的话，如果再简单一点，就像执行node_modules中.bin文件的话，那就可以使用npx



### 局部环境执行webpack方法三

使用npx

npx 会自动找到当前文件夹下的node_modules/.bin文件夹下找到对应的文件，并执行

```js
npx webpack --version
```

![image-20220821111008238](.\.\assets\4_包管理工具详解.assets\image-20220821111008238.png)

![image-20220821111030247](.\.\assets\4_包管理工具详解.assets\image-20220821111030247.png)

所以再看这句话

npx的原理非常简单，它会到当前目录的node_modules/.bin目录下查找对应的命令；







## npm发布自己的包

![image-20220821113606233](.\.\assets\4_包管理工具详解.assets\image-20220821113606233.png)

那么怎么发布包呢

![image-20220821113730100](.\.\assets\4_包管理工具详解.assets\image-20220821113730100.png)

![image-20220821113812805](.\.\assets\4_包管理工具详解.assets\image-20220821113812805.png)







注册npm账号：

- https://www.npmjs.com/
- 选择sign up

在命令行登录：

```js
npm login
```

修改package.json

发布到npm registry上

```js
npm publish
```

更新仓库：

- 1.修改版本号(最好符合semver规范)
- 2.重新发布

删除发布的包：

```js
npm unpublish
```

让发布的包过期：

```js
npm deprecate
```

![image-20220726204317981](.\.\assets\4_包管理工具详解.assets\image-20220726204317981.png)

author: 开发人员

repository: 自己的仓库，这是都要填的

![image-20220821120013528](.\.\assets\4_包管理工具详解.assets\image-20220821120013528.png)



Homepage: 如果有自己的官网的话，可以填自己的官网，没有的话也是填github

![image-20220821120103479](.\.\assets\4_包管理工具详解.assets\image-20220821120103479.png)



keywords: 搜索关键字

![image-20220821120158756](.\.\assets\4_包管理工具详解.assets\image-20220821120158756.png)



比如这里写一些代码

![image-20220821120310188](.\.\assets\4_包管理工具详解.assets\image-20220821120310188.png)



首先要在npm的官网里面有账号

![image-20220821120346727](.\.\assets\4_包管理工具详解.assets\image-20220821120346727.png)



然后登录

![image-20220821120514315](.\.\assets\4_包管理工具详解.assets\image-20220821120514315.png)

发布自己的包

![image-20220821120857530](.\.\assets\4_包管理工具详解.assets\image-20220821120857530.png)

这样就发布好了

![image-20220821121254862](.\.\assets\4_包管理工具详解.assets\image-20220821121254862.png)

我们在npm看一下

![image-20220821121313731](.\.\assets\4_包管理工具详解.assets\image-20220821121313731.png)

这个就是我们填的

那么别人怎么用呢？

我们初始化一个package.json

然后安装这个包

![image-20220821121438996](.\.\assets\4_包管理工具详解.assets\image-20220821121438996.png)

引入这个包，调用这个包

![image-20220821121533054](.\.\assets\4_包管理工具详解.assets\image-20220821121533054.png)



如果想更新包呢？

![image-20220821121700045](.\.\assets\4_包管理工具详解.assets\image-20220821121700045.png)

这个时候要重新发布

![image-20220821121847630](.\.\assets\4_包管理工具详解.assets\image-20220821121847630.png)

![image-20220821121941609](.\.\assets\4_包管理工具详解.assets\image-20220821121941609.png)

![image-20220821122044403](.\.\assets\4_包管理工具详解.assets\image-20220821122044403.png)

![image-20220821122106485](.\.\assets\4_包管理工具详解.assets\image-20220821122106485.png)

这里就更新掉了

![image-20220821122136937](.\.\assets\4_包管理工具详解.assets\image-20220821122136937.png)

这里也更新了

![image-20220821122220792](.\.\assets\4_包管理工具详解.assets\image-20220821122220792.png)